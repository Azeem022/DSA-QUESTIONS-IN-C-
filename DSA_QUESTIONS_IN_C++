//####################################### QUESTION CONVERT DECIMAL TO BINARY ####################################################################
#include<iostream>
#include<math.h>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the number"<<n<<endl;
	cin>>n;
	int ans = 0;
	int i = 0;
	while(n!=0)
	{
		int bit = n & 1;
		ans = (bit * pow(10,i)+ans);
		n = n>>1;
		i++;
	}
	cout<<"Answer is :"<<ans<< endl;
	return 0;
}

                          OR         OR         OR          OR            OR           OR             OR             OR


//################################## DECIMAL TO BINARY #################################################
#include<iostream>
using namespace std;
int main()
{
    int num;
    cout<<"Enter the number:";
    cin>>num;
    int rem, ans=0,mul=1;
    while(num>0)
    {
    	//remainder
    	rem = num%2;
    	//quotient
    	num = num/2;
    	//ans
    	ans= rem*mul+ans;
    	//mul
    	mul=mul*10;
	}
	cout<<"Answer is :"<<ans;
	return 0;
}

TRICK FOR CONVERSION OF BINARY TO DECIMAL AND DECIMAL TO BINARY ONLY YOU HAVE TO CHANGE 2 IN PLACE OF 10 AND 10 IN PLACE OF 2.

//#######################################QUESTION BINARY TO DECIMAL####################################################################
#include<iostream>
#include<math.h>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the number"<<n<<endl;
	cin>>n;
	int ans = 0;
	int i = 0;
	while(n!=0)
	{
		int digit = n%10;
		if(digit == 1)
		{
			ans = ans + pow(2,i);
		}
		n = n/10;
		i++;
	}
	cout<<"Answer is :"<<ans<< endl;
	return 0;
}

                                      OR         OR           OR            OR                 OR                  OR                     OR

//################################## BINARY TO DECIMAL #################################################
#include<iostream>
using namespace std;
int main()
{
    int num;
    cout<<"Enter the number:";
    cin>>num;
    int rem, ans=0,mul=1;
    while(num>0)
    {
    	//remainder
    	rem = num%10;
    	//quotient
    	num = num/10;
    	//ans 
    	ans= rem*mul+ans;
    	//mul
    	mul=mul*2;
	}
	cout<<"Answer is :"<<ans;
	return 0;
}


//#######################################QUESTION GIVE AN INTEGER NUMBER N,RETURN THE DIFFERENCE BETWEEN THE PRODUCT OF ITS DIGIT AND SUM OF ITS DIGIT####################################################################
#include<iostream>
#include<math.h>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the number"<<n<<endl;
	cin>>n;
    int last_digit,product=1,sum=0;
	while(n!=0)
	{
		int last_digit = n%10;
		product = last_digit*product;
		sum = sum+ last_digit;
		n = n/10;

	}
	int difference = product - sum;
	cout<<"product is :"<<product<<endl;
	cout<<"sum is :"<<sum<<endl;
	cout<<"difference is :"<<difference<< endl;
	return 0;
}

//############################## QUESTION GIVE A SIGNED 32_BIT INTEGER X, RETURN X WITH ITS DIGITS REVERSED. 
//IF REVERSING X CUSES THE VALUE TO GO OUTSIDE THE SIGNED 32_BIT INTEGER RANGE [-2*(32),2(31)-1],THEN RETURN 0 #################################
#include<iostream>
#include<math.h>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the number"<<n<<endl;
	cin>>n;
    int last_digit,ans=0;
	while(n!=0)
	{
		int last_digit = n%10;
	 if(ans > INT_MAX/10 || ans < INT_MIN/10)
	 {
	 	return 0;
	 }
	 ans = (ans * 10) + last_digit;
	 n=n/10;
	}
	cout<<"anser is :"<<ans<<endl;
	return 0;
}

       OR             OR         OR           OR            OR                 OR                  OR                     OR

//############################## QUESTION GIVE A SIGNED 32_BIT INTEGER X, RETURN X WITH ITS DIGITS REVERSED. 
//IF REVERSING X CUSES THE VALUE TO GO OUTSIDE THE SIGNED 32_BIT INTEGER RANGE [-2*(32),2(31)-1],THEN RETURN 0 #################################

//################################## GIVEN AN INTEGER NUM, REPEATIDLY ADD ALL ITS DIGIT UNTIL THE RESULT HAS ONLY ONE DIGIT, AND RETURN IT. #################################################
#include<iostream>
using namespace std;
int main()
{
    int num;
    cout<<"Enter the number:";
    cin>>num;
    int ans=0,rem,div;
    while(num!=0)
    {
    	rem=num%10;
    	num=num/10;
    	if(ans>INT_MAX/10 || ans<INT_MIN/10)
    	return 0;
    	ans=ans*10+rem;
	}
	cout<<ans;
	return 0;
}



//################################## GIVEN AN INTEGER NUM, REPEATIDLY ADD ALL ITS DIGIT UNTIL THE RESULT HAS ONLY ONE DIGIT, AND RETURN IT. #################################################
#include<iostream>
using namespace std;
int main()
{
    int num;
    cout<<"Enter the number:";
    cin>>num;
    while(num>9)
    {
    	int rem, ans=0;
    	while(num>0)
    {
    	//remainder
    	rem = num%10;
    	//quotient  
    	num = num/10;
    	//ans 
    	ans= rem+ans;
    	//mul
	}
	 num=ans;
	}
	cout<<num;
	return 0;
}

//################################## GIVEN AN INTEGER n,RETURN TRUE IF IT THE POWER OF 2 OTHERWISE IT RETURN FALSE. #################################################
#include<iostream>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the value of n:"<<endl;
	cin>>n;
	if(n<1)
	return 0;
	while(n!=1)
	{
		if(n%2==1)
		return 0;
		n=n/2;
	}
	cout<<"yes it is the power of 2"<<endl;
	return 0;
}

//################################## SQUARE ROOT OF N NUMBER. #################################################
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the value of n:"<<endl;
	cin>>n;
	cout<<sqrt(n);
	return 0;
}

//====================================PRIME NUMBER OR NOT ===================================================
#include <iostream>
using namespace std;
int main() {
   int n,i;
   cout<<"enter the number :"<<endl;
   cin>>n;
   if(n<2)
   {
       cout<<"not prime number:";
       return 0;

   }
   else
   {
       for(i=2;i<n;i++)
           {
               if(n%i==0){
                   cout<<"not prime";
                   return 0;
               }
           }
       cout<<"prime number";
       return 0;
   }
    return 0;
}



//################################## PALENDROME OR NOT. #################################################
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
	int x;
	cout<<"Enter the value of x:"<<endl;
	cin>>x;
	if(x<0)
	return 0;
	int num = x, rem, ans=0;
	while(num!=0)
	{
		rem = num%10;
		num =  num/10;
		if(ans>INT_MAX)
		return 0;
		ans = ans*10+rem;
	};
	if(ans==x)
	cout<<"Palendrome"<<endl;
	else
	cout<<"Not Palendrome"<<endl;
	return 0;
}

//################################## COMPLEMENT OF AN INTEGER. #################################################
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    int n;
    cout<<"Enter the value of n:"<<endl;
    cin>>n;
    if(n==0)
    return 0;
    int ans=0,rem,mul=1;
    while(n!=0)
    {
    	rem=n%2;
    	rem=rem^1;
    	n=n/2;
    	ans = ans+rem*mul;
    	mul=mul*2;
	}
	cout<<ans;
	return 0;
}


//################################## ARMSTRONG NUMBER OR NOT WITH HOW MANY DIGITS. #################################################
#include<iostream>
using namespace std;
#include<cmath>
int countdigit(int n)
{
	int count = 0;
	while(n!=0)
	{
		count ++;
		n=n/10;
	}
	return count;
}
bool Armstrong(int num , int digit)
{
	int n=num,ans=0,rem;
	while(n!=0)
	{
		rem=n%10;
		n=n/10;
		ans=ans+pow(rem,digit);
	}
	if(ans==num)
	return 1;
	else
	return 0;
}
int main()
{
	int num;
	cout<<"Enter the value of number:"<<endl;
	cin>>num;
	int digit = countdigit(num);
	cout<<"number of digit:"<<countdigit(num)<<endl;;
	cout<<"Is Armstrong number:"<<Armstrong(num,digit);//?"yes":"no";
	return 0;
}

===================================== PRINT SMALLEST ARRAY IN AN ARRAY =======================================
#include<iostream>
using namespace std;
int main()
{
	int arr[5]= {55,63,33,44,55};
	int ans= INT_MAX;
	for(int i=0;i<5;i++)
	{
		if(arr[i]<ans){
			ans=arr[i];
		}
	}
	cout<<ans;
	return 0;
}

//===================================== PRINT LARGEST ARRAY IN AN ARRAY =======================================
#include<iostream>
using namespace std;
int main()
{
	int arr[5]= {55,63,33,44,55};
	int ans= INT_MIN;
	for(int i=0;i<5;i++)
	{
		if(arr[i]>ans){
			ans=arr[i];
		}
	}
	cout<<ans;
	return 0;
}

//===================================== SEARCHING OF ARRAY =======================================
#include<iostream>
using namespace std;
int main()
{
	int n,x;
	cout<<"entre the value of n:"<<endl;
	cin>>n;
	cout<<"Enter the value which you want to find:"<<endl;
	cin>>x;
	int arr[n];
	for(int i=0;i<n;i++)
	{
		cin>>arr[i];
	}
	for(int i=0;i<=n;i++)
	{
	    if(arr[i]==x)
	    {
	    	cout<<"position of your element is:"<<i<<endl;
		}
	}
	return -1;
	return 0;
}

//===================================== REVERSE OF AN ARRAY =======================================
#include<iostream>
using namespace std;
int main()
{
	int arr[6]= {1,2,3,4,5,6};
	int start=0, end=5;
	while(start<end)
	{
		swap(arr[start],arr[end]);
		start++;
		end--;
	}
	for(int i=0;i<6;i++)
	cout<<arr[i]<<" ";
	return 0;
}

//===================================== SECOND LARGEST ELEMENT IN AN ARRAY =======================================
#include<iostream>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the size of an array:"<<endl;
	cin>>n;
	int arr[n];
	for(int i=0;i<n;i++)
	{
		cin>>arr[i];
	}
	int ans=-1;
	//Largest element
	for(int i=0;i<n;i++)
	{
		if(arr[i]>ans)
		ans=arr[i];
	}
	//Second largest
	int second = -1;
	for(int i=0;i<n;i++)
	{
		if(arr[i]!=ans)
		second = max(second,arr[i]);
	};
	cout<<"second largest element is:"<<second<<endl;
	return 0;
}

//===================================== MISSING ELEMENT IN AN ARRAY =======================================
#include<iostream>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the size of an array:"<<endl;
	cin>>n;
	int arr[n];
	for(int i=0;i<n;i++)
	{
		cin>>arr[i];
	}
	int sum=0;
	for(int i=0;i<n-1;i++)
	{
		sum+=arr[i];
	}
	int ans = n*(n+1)/2;
	cout<<"missing element is:"<< ans - sum;
	return 0;
}


//===================================== FIND AN ARRAY IN FIBONACCI SERIES  =======================================
#include<iostream>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the size of an array:"<<endl;
	cin>>n;
	int arr[1000];
	arr[0] = 0;
	arr[1] = 1;
	for(int i=2;i<=n-1;i++)
    {
    arr[i] = arr[i-1] + arr[i-2];
	}
	cout<<arr[n-1]<<" ";
	return 0;
}

//===================================== SELECTION SORTING OF ARRAY  =======================================
#include<iostream>
using namespace std;
int main()
{
	int arr[6] = { 10,8,6,4,2,1};
	for(int i=0;i<5;i++)
	{
                	//it assume that the index which stored the smallest element initially 
		int index = i;
		for(int j=i+1;j<6;j++)
		{
			if(arr[j]<arr[index])
			index = j;
		}
		swap(arr[i],arr[index]);
	}
	for(int i=0;i<6;i++)
	{
		cout<<arr[i]<<" ";
	}
}

//================================== INSERTION SORT =========================================
#include<iostream>
using namespace std;
int main()
{
	int n;
	cout<<"enter the size of an array:"<<endl;
	cin>>n;
	int arr[1000];
	for(int i=0;i<n;i++)
	cin>>arr[i];
	for(int i=1;i<n;i++)
	{
		for(int j=i;j>0;j--)
		{
			if(arr[j]<arr[j-1])
			swap(arr[j],arr[j-1]);
			else
			break;
		}
	}
	for(int i=0;i<n;i++)
	{
		cout<<arr[i]<<" ";
	}
	return 0;
}

//================================== BINARY SEARCH =========================================
#include<iostream>
using namespace std;
int BinarySearch(int arr[], int n,int key)
{
	//start , end , mid
	int start = 0, end = n-1, mid;
	while(start<=end)
	{
		//mid ko find kro
		mid = start+(end-start)/2;
		//arr[mid]==key
		if(arr[mid]==key)
		return mid;
		//arr[mid]<key
		else if (arr[mid]<key)
		start = mid + 1;
		//arr[mid]>key
		else
		mid-1;
	}
	return -1;
}
int main()
{
	int n;
	cout<<"Enter the size of an array:"<<endl;
	cin>>n;
	int arr[1000];
	cout<<"Enter element in an array:"<<endl;
	for(int i=0;i<n;i++)
	{
		cin>>arr[i];
	}
	int key;
	cout<<"Enter the value of key:"<<endl;
	cin>>key;
	cout<<BinarySearch(arr,n,key)<<endl;
	return 0;
}

//============================ SEARCH POSITION OF UNPRESENT ARRAY IN ARRAY LIST USING BINARY SEARCH =========================
#include<iostream>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the size of an array:"<<endl;
	cin>>n;
	if(n <= 0)
	{
		cout<<"Invalid array size."<<endl;
		return 1;
	}
	int target;
	cout<<"Enter the value of your target:"<<endl;
	cin>>target;
	cout<<"input the values of your array"<<endl;
	int arr[1000];
	for(int i = 0; i<n;i++)
	{
		cin>>arr[i];
	}
	//finding the first occurence
	int start = 0, end = n-1, mid , ans=n;
	while(start<= end)
	{
		mid = start + (end - start)/2;
		if(arr[mid] == target)
		{
			ans = mid;
			break;
		}
		else if(arr[mid]<target)
		{
			start = mid+1;
		}
		else
		{
			ans = mid;
			end = mid -1;
		}
	}
	cout<<"your target value will on " << ans <<" position"<<endl;
	return 0;
}

//===========================SQUARE ROOT USING BINARY SEARCH ==========================
#include<iostream>
using namespace std;
int sqrt(int n){
	int start=1;
	int end=n;
	int ans =1;
	while(start<=end)
	{
		int mid = start+(end-start)/2;
		int sqrt = mid*mid;
		if(sqrt<=n){
			start =mid +1;
			ans = mid;
		}
		else{
			end = mid - 1;
		}
	}
	return ans;
}
int main()
{
	int n;
	cout<<"Enter the value of n:"<<endl;
	cin>>n;
	cout<<"square root of "<<n<<" is : "<<sqrt(n) <<endl;
	return 0;
}

//============================PEAK INDEX IN A MOUNTAIN ARRAY ==================================
#include<iostream>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the size of an array:"<<endl;
	cin>>n;
	cout<<"fill your array element:"<<endl;
	int arr[1000];
	for(int i=0;i<n;i++)
	{
		cin>>arr[i];
	} 
	 int start = 0, end = n-1, mid;
	 while(start <= end)
	 {
	 	mid = end+(start-end)/2;
	 	//Peak element
	 	if(arr[mid] > arr[mid-1] && arr[mid] < arr[mid+1])
	 	return mid;
	 	else if(arr[mid]>arr[mid-1])
	 	start = mid + 1;
	 	else
	 	end = mid -1;
	 }
	 cout<<"Your peak element on " <<mid <<" position";
	return 0;
}

//===========================================ROTATED MINIMUM SORTED ARRAY ==========================================================
#include<iostream>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the size of an array:"<<endl;
	cin>>n;
	cout<<"Enter your "<< n <<" array"<<endl;
	int arr[n];
	for(int i =0;i<n;i++)
	{
		cin>>arr[i];
	}
	int start =0, end = n-1, ans = arr[0];
	while(start<=end)
	{
		int mid = start+(end-start)/2;
		
		//left side sorted array
		if(arr[mid] >= arr[0])
		start = mid + 1;
		
		//right side sorted
		else
		{
			ans = arr[mid];
			end = mid - 1;
		}
	}
	cout<< ans;
	return 0;
}

//====================================BINARY SEARCH ROTATED ARRAY =========================
#include <iostream>
using namespace std;

int binarySearchRotated(int arr[], int n, int target) {
    int start = 0, end = n - 1;

    while (start <= end) {
        int mid = start + (end - start) / 2;

        if (arr[mid] == target) {
            return mid;
        }

        // Determine which part is sorted
        if (arr[start] <= arr[mid]) {
            // Left side is sorted
            if (arr[start] <= target && target < arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        } else {
            // Right side is sorted
            if (arr[mid] < target && target <= arr[end]) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
    }

    // Target not found
    return -1;
}

int main() {
    int n;
    cout << "Enter the size of array:" << endl;
    cin >> n;

    if (n <= 0 || n > 1000) {
        cout << "Array size should be between 1 and 1000." << endl;
        return 1;
    }

    int arr[1000];
    cout << "Fill your array:" << endl;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    int target;
    cout << "Enter your target value:" << endl;
    cin >> target;

    int result = binarySearchRotated(arr, n, target);

    if (result != -1) {
        cout << "Your answer is: " << result << endl;
    } else {
        cout << "Target not found in the array." << endl;
    }

    return 0;
}


//====================================kth MISSING POSITIVE INTEGER IN BINARY SEARCH ROTATED ARRAY =========================
#include <iostream>
#include <vector>
using namespace std;

// Function to count the number of missing positive integers up to a given value
int countMissingUpTo(const vector<int>& arr, int value) {
    int missingCount = 0;
    int n = arr.size();
    int start = 0;
    int end = n - 1;

    while (start <= end) {
        int mid = start + (end - start) / 2;
        if (arr[mid] <= value) {
            missingCount = arr[mid] - (mid + 1);  // Calculate the missing count up to arr[mid]
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }

    return missingCount;
}

// Function to find the kth missing positive integer in a rotated sorted array
int findKthMissingPositive(const vector<int>& arr, int k) {
    int n = arr.size();
    int start = 1;  // Start with the first positive integer
    int end = arr[n - 1] + k;  // Upper bound to search

    while (start <= end) {
        int mid = start + (end - start) / 2;
        int missingCount = countMissingUpTo(arr, mid);

        if (missingCount < k) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }

    return start;
}

// ==========================================Function to find the index of the smallest element (rotation point) in a rotated sorted array================================================
int findRotationPoint(const vector<int>& arr) {
    int start = 0;
    int end = arr.size() - 1;

    while (start < end) {
        int mid = start + (end - start) / 2;
        if (arr[mid] > arr[end]) {
            start = mid + 1;
        } else {
            end = mid;
        }
    }

    return start;
}

int main() {
    int n, k;
    cout << "Enter the size of the array: ";
    cin >> n;
    vector<int> arr(n);

    cout << "Enter the elements of the rotated sorted array: ";
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }

    cout << "Enter the value of k: ";
    cin >> k;

    int rotationPoint = findRotationPoint(arr);
    vector<int> sortedArr;

    // Construct sorted array from rotation point
    for (int i = rotationPoint; i < n; ++i) {
        sortedArr.push_back(arr[i]);
    }
    for (int i = 0; i < rotationPoint; ++i) {
        sortedArr.push_back(arr[i]);
    }

    int result = findKthMissingPositive(sortedArr, k);
    cout << "The " << k << "th missing positive integer is: " << result-1 << endl;

    return 0;
}
//==========================================you have N book, each with A[I] number of pages. M students need to be allocated contiguous books , with each student at-least one book. Out of permutations, the goal is to find the permutation where the student with the most books allocated to him gets the minimum number of pages out of all possible permutation. Return -1 if a valid assignment is not possible ====================
#include <iostream>
#include <vector>
#include <numeric>
using namespace std;

bool isFeasible(const vector<int>& A, int M, int maxPages) {
    int studentCount = 1;
    int currentPages = 0;

    for (int pages : A) {
        if (pages > maxPages) {
            return false; // A single book cannot exceed maxPages
        }
        
        if (currentPages + pages > maxPages) {
            studentCount++; // Need to allocate to a new student
            currentPages = pages; // Start with the current book
            if (studentCount > M) {
                return false; // More students than allowed
            }
        } else {
            currentPages += pages; // Add pages to current student's total
        }
    }

    return true; // Feasible to allocate books under current maxPages
}

int allocateBooks(const vector<int>& A, int M) {
    int n = A.size();
    if (n < M) {
        return -1; // Not enough books for students
    }

    int low = *max_element(A.begin(), A.end()); // Maximum single book pages
    int high = accumulate(A.begin(), A.end(), 0); // Total pages

    int result = high; // Initialize result

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (isFeasible(A, M, mid)) {
            result = mid; // Found a feasible allocation
            high = mid - 1; // Try for a better (lower) maximum
        } else {
            low = mid + 1; // Increase maximum pages
        }
    }

    return result;
}

int main() {
    int n, m;
    cout << "Enter the number of books: ";
    cin >> n;
    vector<int> A(n);

    cout << "Enter the number of pages in each book: ";
    for (int i = 0; i < n; ++i) {
        cin >> A[i];
    }

    cout << "Enter the number of students: ";
    cin >> m;

    int result = allocateBooks(A, m);
    cout << "The minimum number of pages allocated to the student with the most pages is: " << result << endl;

    return 0;
}

// ==============================  PAINTER PARTITION PROBLEM  ====================================================================
#include <iostream>
#include <numeric>
#include <algorithm> // For std::max
using namespace std;

// Function to check if it's feasible to allocate books to students
bool isFeasible(int A[], int n, int M, int maxPages) {
    int studentCount = 1; // Start with one student
    int currentPages = 0;

    for (int i = 0; i < n; i++) {
        if (A[i] > maxPages) {
            return false; // A single book cannot exceed maxPages
        }
        
        // Check if adding this book exceeds the limit
        if (currentPages + A[i] > maxPages) {
            studentCount++; // Need to allocate to a new student
            currentPages = A[i]; // Start with the current book
            if (studentCount > M) {
                return false; // More students than allowed
            }
        } else {
            currentPages += A[i]; // Add pages to the current student's total
        }
    }

    return true; // Feasible to allocate books under current maxPages
}

// Function to allocate books and minimize the maximum pages
int allocateBooks(int A[], int n, int M) {
    if (n < M) {
        return -1; // Not enough books for students
    }

    int low = *max_element(A, A + n); // Maximum single book pages
    int high = accumulate(A, A + n, 0); // Total pages

    int result = high; // Initialize result

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (isFeasible(A, n, M, mid)) {
            result = mid; // Found a feasible allocation
            high = mid - 1; // Try for a better (lower) maximum
        } else {
            low = mid + 1; // Increase maximum pages
        }
    }

    return result;
}

int main() {
    int n, m;

    cout << "Enter the number of books: ";
    cin >> n;
    int A[n];  // Declare an array of size n

    cout << "Enter the number of pages in each book: ";
    for (int i = 0; i < n; ++i) {
        cin >> A[i];
    }

    cout << "Enter the number of students: ";
    cin >> m;

    int result = allocateBooks(A, n, m);
    cout << "The minimum number of pages allocated to the student with the most pages is: " << result << endl;

    return 0;
}



//================================= STL =============================STL================================================STL=======================================
#include<iostream>
#include<vector>
using namespace std;

int main()
{
	// create vector, declare vector1
	vector<int>vector1; 
	
	//size and capacity of vector1
	cout<<"size of vector1 : "<<vector1.size()<<endl;
	cout<<"capacity of vector1 : "<<vector1.capacity()<<endl;
	
	// Adding element to vector1
	vector1.push_back(2);
	vector1.push_back(3);
	vector1.push_back(10);
	cout<<"size of vector1 after adding element : "<<vector1.size()<<endl;
	cout<<"capacity of vector1 after adding element : "<<vector1.capacity()<<endl;
	
	//Update value in vector1
	vector1[1] = 5;  //update second element

//create and manipulate another vector
    vector<int>vector1new;
    vector1new.push_back(4);
    vector1new.push_back(41);
    vector1new.push_back(14);
    vector1new.push_back(42);
    vector1new.push_back(84);
    
    //delete last element
    vector1new.pop_back();
    cout<<"size of vector1new after pop_back: "<<vector1new.size()<<endl;
	cout<<"capacity of vector1new after pop_back: "<<vector1new.capacity()<<endl;
	
    //delete element which you want
    if(vector1new.size()>1)
    {
    	vector1new.erase(vector1new.begin()+1);//itremove 41 element.
	}
    cout<<"size of vector1new after erasing element at index 1 : "<<vector1.size()<<endl;
	cout<<"capacity of vector1new after erasing element : "<<vector1.capacity()<<endl;
	
	//print the contents of vecctor1new
	cout<<"==========Content of vector1new=========="<<endl;
	for(int i = 0; i < vector1new.size(); i++)
	{
		cout<<vector1new[i]<<" ";
	}
	cout << endl;
	
	// we are adding 1 element at position 1.
		vector1new.insert(vector1new.begin()+1,50);
		cout<<endl;
		for(int i = 0; i < vector1new.size(); i++)
	    {
		cout<<vector1new[i]<<" ";
	    }
	    cout<<endl;
	    
	    //Exchange 50 with 37
	    for(int i=0; i<vector1new.size();i++)
	    {
	    	if(vector1new[i]==50)
	    	{
	    		vector1new[i]=37;// update 50 to 37
	    		break; //Exit loop after replacement
			}
		}
		//print the contents of vecctor1new
	cout<<"==========Content of vector1new after replace 37 in palace of 50=========="<<endl;
	for(int i = 0; i < vector1new.size(); i++)
	{
		cout<<vector1new[i]<<" ";
	}
	cout << endl;
	return 0;
}


//===========///////////////==================//////////////////=================///////////////=============///////////
int main()
{
	vector<int>arr;
	arr.push_back(2);
	arr.push_back(12);
	arr.push_back(21);
	arr.push_back(122);
	cout<<arr[0]<<endl;
	cout<<arr.front()<<endl;
	cout<<arr[arr.size()-1]<<endl;
	cout<<arr.back()<<endl;
	for(auto i: arr)
	cout<<i<<" ";
	return 0;
}

int main()
{
	vector<int>ans;
	ans.push_back(345);
	ans.push_back(55);
	ans.push_back(56);
	ans.push_back(35);
	ans.push_back(59);
	
	// sort in increasing order
	sort(ans.begin(),ans.end());
	for(int i=0; i<ans.size(); i++)
	{
		cout<<ans[i]<<" ";
	}
	
	// sort in decreasing order
	sort(ans.rbegin(),ans.rend());
	for(int i=0; i<ans.size(); i++)
	{
		cout<<ans[i]<<" ";
	}
   //search in binary search
     cout<<binary_search(ans.begin(), ans.end(), 55)<<endl;//present or not
     cout<<find(ans.begin(),ans.end(),54)-ans.begin()<<endl;// at which position element is present
}

//================================= TWO POINTERS IN AN ARRAY========================================
#include<iostream>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the length of array :"<<endl;
	cin>>n;
	int arr[1000];
	for(int i=0; i<n;i++)
	{
		cin>>arr[i];
	}
	int start = 0, end = n-1;
	while(start < end)
	{
		if(arr[start]==0)
		start++;
		else
		{
			if(arr[end]==0)
			{
				swap(arr[start], arr[end]);
				start++;
				end--;
			}
			else
			end--;
		}
	}
	cout<<"your sorted array is :";
	for(int i=0;i<n;i++)
	{
		cout<<arr[i]<<" ";
	}
	cout<<endl;
	return 0;
}

//================================= TWO POINTERS IN AN ARRAY========================================
//==================================TWO SUM================================================
#include<iostream>
using namespace std;
int main()
{
	int n;
	cout<<"Enter the length of array :"<<endl;
	cin>>n;
	int arr[1000];
	for(int i=0; i<n;i++)
	{
		cin>>arr[i];
	}
	int start = 0, end = n-1, target = 22;
//	bool found = false;
	while(start < end)
	{
		if(arr[start] + arr[end]==target)
		{
			cout<<"pair found "<<arr[start]<<" and "<<arr[end]<<" and the sum of these two pair is :"<<arr[start]+ arr[end]<<endl;
		//	found = true;
			break;
		}
		else if(arr[start] + arr[end] < target)
		{
			start++;
		}
		else
	    {
	       end--;
		}
	}
	return 0;
}


//================================= TWO POINTERS IN AN ARRAY(DIVIDE ARRAY IN TWO SUB ARRAY WITH EQUAL SUM)========================================

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

bool divide(vector<int>arr)
{
	int maxi = INT_MIN, prefix=0, total_sum=0, n = arr.size();
	
	//Total sum
	for(int i=0;i<n;i++)
	{
		total_sum = total_sum + arr[i];
	}
	for(int i=0;i<n;i++)
	{
		prefix = prefix + arr[i];
		int ans = total_sum - prefix;
		if(ans == prefix)
	 	return 1;
	}
	return 0;
}

int main()
{
	int n;
	cout<<"Enter the size of an array : "<<endl;
	cin>>n;
	vector<int>v(n);
	cout<<"Enter the element in an array : "<<endl;
	for(int i=0;i<n;i++)
	{
		cin>>v[i];
	}
	cout<<divide(v);
	return 0;
}


//=====================LARGEST SUM CONTIGUOUS SUBARRAY(KADANE'S ALGORITHM)========================

#include<iostream>
#include<algorithm>
using namespace std;

long long maxSubarraySum(int arr[], int n)
{
	long long maxi = INT_MIN, prefix = 0;
	for(int i = 0; i<n; i++)
	{
		prefix = prefix + arr[i];
		maxi = max(prefix, maxi);
		if(prefix<0)
		{
			prefix = 0;
		}
	}
	return maxi;
}

int main()
{
	int n,maxi;
	cout<<"Enter the size of an array : "<<endl;
	int arr[1000];
	cin>>n;
	cout<<"Enter the element which you want to insert : "<<endl;
	for(int i=0; i<n; i++)
	{
		cin>>arr[i];
	}
	long long result = maxSubarraySum(arr, n);
	cout<<"your ans is : "<<result;
	return 0;
}


//==========================================RAIN WATER TRAPPING PROBLEM =====================================================================
#include<iostream>
#include<algorithm>
using namespace std;

int rain_water(int a[], int n)
{
	int left[n];
	int right[n];
	left[0] = a[0];
	for(int i=1; i<n;i++)
	{
		left[i] = max(left[i-1], a[i]);
	}
	right[n-1] = a[n-1];
	for(int i=n-2; i >=0; i-- )
	{
		right[i] = max(right[i+1], a[i]);
	}
	
	int ans = 0;
	for(int i = 0; i<n; i++)
	{
		ans = ans+(min(left[i], right[i]) -a[i]);
	}
	return ans;
}

int main()
{
	int n;
	cout<<"Enter the size of an array : "<<endl;
	cin>>n;
	int arr[1000];
	cout<<"Enter the element which you want to fill in array : "<<endl;
	for(int i = 0; i<n; i++)
	{
		cin>>arr[i];
	}
	int result = rain_water(arr, n);
	cout<<"the amount of water that can be trapped is : "<<result<<endl;
	return 0;
}


============###########==============####################=====================#######################========================##################################===========================
============###########==============####################=====================#######################========================##################################===========================
============###########==============####################=====================#######################========================##################################===========================
============###########==============####################=====================#######################========================##################################===========================

//=============================Insertion IN ARRAY in begning ================================================
#include<iostream>
using namespace std;
int main()
{
	int arr[10], n, x;
	cout<<"Enter the size of an array:"<<endl;
	cin>>n;
	cout<<"Enter the element in an array : "<<endl;
	for(int i=0;i<n;i++)
	{
		cin>>arr[i];
	}
	cout<<"Enter the element at the begning"<<endl;
	cin>>x;
	for(int i=n;i>0;i--)
	{
		arr[i] = arr[i-1];
	}
	arr[0] = x;
	n++;
	cout<<"After insertion array element are :"<<endl;
	for(int i=0;i<n;i++)
	{
		cout<<arr[i]<<endl;
	}
	return 0;
}


//=============================Deletion IN ARRAY in begning ================================================
#include<iostream>
using namespace std;
int main()
{
	int arr[10], n, x;
	cout<<"Enter the size of an array:"<<endl;
	cin>>n;
	cout<<"Enter the element in an array : "<<endl;
	for(int i=0;i<n;i++)
	{
		cin>>arr[i];
	}
	cout<<"Delete the element at the begning"<<endl;
	for(int i=0;i<n-1;i++)
	{
		arr[i] = arr[i+1];
	}
	n--;
	for(int i=0;i<n;i++)
	{
		cout<<arr[i]<<endl;
	}
	return 0;
}


//=============================Deletion IN ARRAY in specific position ================================================
#include<iostream>
using namespace std;
int main()
{
	int arr[10],n,position;
	cout<<"Enter the size of an array:"<<endl;
	cin>>n;
	cout<<"Enter your element : "<<endl;
	for(int i=0;i<n;i++)
	{
		cin>>arr[i];
	}
	cout<<"Enter the position in an array you want to delete : "<<endl;
	cin>>position;
	cout<<"After Delete the element at a specific  position"<<endl;
	for(int i=position;i<n;i++)
	{
		arr[i] = arr[i+1];
	}
	n--;
	for(int i=0;i<n;i++)
	{
		cout<<arr[i]<<endl;
	}
	return 0;
}


============LINKED LIST==============LINKED LIST=====================LINKED LIST========================LINKED LIST===========================
============LINKED LIST==============LINKED LIST=====================LINKED LIST========================LINKED LIST===========================
============LINKED LIST==============LINKED LIST=====================LINKED LIST========================LINKED LIST===========================
============LINKED LIST==============LINKED LIST=====================LINKED LIST========================LINKED LIST===========================

//===========================SIMPLE LINKED LIST PROGRAM===================
#include<iostream>
using namespace std;

//Linkedlist Node
struct node{
	int data;
	node *next;
};

void printlist(node *head)
{
	while(head!=NULL)
	{
		cout<<head->data<<endl;
		head = head->next;
	}
}

int main()
{
	node *head = new node();
	node *second = new node();
	node *third = new node();
	
	head->data = 5;
	head->next = second;
	
	second->data = 7;
	second->next = third;
	
	third->data = 9;
	third->next = NULL;
	
	printlist(head);
}  

//===========================ADD A NODE AT THE FRONT OF LINKED LIST===================

#include <iostream>
using namespace std;

class Node {
public: 
    int data;
    Node* next;

    Node(int value) {
        data = value;
        next = NULL;
    }
};

int main() {
    Node *Head = NULL; // Initialize Head to nullptr
    Node *temp = NULL;

    int arr[] = {2, 4, 6, 8, 10};

    // Inserting nodes at the front of the linked list
    for (int i = 0; i < 5; i++) {
        Node* newNode = new Node(arr[i]); // Create a new node
        newNode->next = Head; // Point new node to current head
        Head = newNode; // Update head to the new node
    }

    // Print the linked list
    temp = Head; // Set temp to Head for traversal
    while (temp != NULL) {
        cout << temp->data << " -> ";
        temp = temp->next;
    }
    cout << "NULL" << endl;

    // Cleanup: Free remaining nodes
    while (Head != NULL) {
        Node* toDelete = Head;
        Head = Head->next;
        delete toDelete;
    }

    return 0;
}



//===========================ADD A NODE AT THE FRONT OF LINKED LIST===================
#include<iostream>
using namespace std;

//Linkedlist Node
struct node{
	int data;
	node *next;
};

void printlist(node *head)
{
	int count = 0;
	while(head!=NULL)
	{
		cout<<head->data<<endl;
		head = head->next;
		count++;
	}
	cout<<"No. of element in linked list is : "<<count<<endl;
}

void push(node **head_ref, int newData)  //head_ref bhi head ka address store kr rha iska mtlb head_ref bhi indirectly head hi hai
{
	node *newNode = new node();
	newNode -> data = newData;
	newNode -> next = *head_ref;
	*head_ref = newNode;
}
int main()
{
	node *head = NULL;
	push(&head, 5);
	push(&head, 7);
	push(&head, -3);
	printlist(head);
}  

OUTPUT IS :
-3
7
5
No. of element in linked list is : 3


// =======================INSERTION ON LINKED LIST AT START =====================
#include<iostream>
using namespace std;

class Node
{
	public:
		int data;
		Node *next;
		
		Node(int value)
		{
			data = value;
			next = NULL;
		}
};
int main()
{
	Node *Head;
	Head = NULL;
//	Head = new Node(4);
//	cout<<Head->data<<endl;
//	cout<<Head->next<<endl;
	
	int arr[] = {2,4,6,8,10};
	//Insert a node at begning.
	
	//Linked list doesnt exist
	
	for(int i=0; i<5;i++)
	{
		if(Head == NULL)
		{
			Head = new Node(arr[i]);
		}
	//  If linkedlist exist.
        else
		{
			Node *temp;
			temp = new Node(arr[i]);
			temp->next = Head;
			Head = temp;
		}	
	} 
	
	// Print the value;
	
	Node *temp = Head;
	while(temp!=NULL)
	{
		cout<<temp->data<<"->";
		temp=temp->next;
	}
	cout<<"NULL";
}


// =======================INSERTION ON LINKED LIST AT END =====================
#include<iostream>
using namespace std;

class Node
{
	public:
		int data;
		Node *next;
		
		Node(int value)
		{
			data = value;
			next = NULL;
		}
};
int main()
{
	Node *Head, *Tail;
	Tail = Head = NULL;
//	Head = new Node(4);
//	cout<<Head->data<<endl;
//	cout<<Head->next<<endl;
	
	int arr[] = {2,4,6,8,10};
	//Insert a node at begning.
	
	//Linked list doesnt exist
	
	for(int i=0; i<5;i++)
	{
		if(Head == NULL)
		{
			Head = new Node(arr[i]);
			Tail = Head;
		}
	//  If linkedlist exist.
        else
		{
			Tail->next = new Node(arr[i]);
			Tail = Tail->next;
		}	
	}
	
	// Print the value;
	                                    
	Node *temp = Head;
	while(temp!=NULL)
	{ 
		cout<<temp->data<<"->";
		temp=temp->next;
	}
	cout<<"NULL";
}


// =======================INSERTION ON LINKED LIST AT END BY RECURSION =====================
#include<iostream>
using namespace std;

class Node
{
	public:
		int data;
		Node *next;
		
		Node(int value)
		{
			data = value;
			next = NULL;
		}
};

Node *CreateLinkedList(int arr[], int index, int size)
{
	// Base case
	if(index == size)
	return NULL;
	
	Node *temp;
	temp = new Node(arr[index]);
	temp->next = CreateLinkedList(arr, index+1, size);
	
	return temp; 
}

int main()
{
	Node *Head;
	Head = NULL;
	
	int arr[] = {2,4,6,8,10};
	
	Head = CreateLinkedList(arr,0,5);
	
	// Print the value;
	                                    
	Node *temp = Head;
	while(temp!=NULL)
	{ 
		cout<<temp->data<<"->";
		temp=temp->next;
	}
	cout<<"NULL";
}


// =======================INSERTION ON LINKED LIST AT BEGNING USING RECURSION =====================
#include<iostream>
using namespace std;

class Node
{
	public:
		int data;
		Node *next;
		
		Node(int value)
		{
			data = value;
			next = NULL;
		}
};

Node *CreateLinkedList(int arr[], int index, int size, Node *prev)
{
	// Base case
	if(index == size)
	{
		return prev;
	}
	
	Node *temp;
	temp = new Node(arr[index]);
	temp->next = prev;
	
	return CreateLinkedList(arr, index+1, size, temp); 
}

int main()
{   
	Node *Head;
	Head = NULL;
	
	int arr[] = {2,4,6,8,10};
	
	Head = CreateLinkedList(arr,0,5,Head);
	
	// Print the value;
	                                    
	Node *temp = Head;
	while(temp!=NULL)
	{ 
		cout<<temp->data<<"->";
		temp=temp->next;
	}
	cout<<"NULL";
}


// =======================DELETE FIRST NODE ON LINKEDLIST  =====================
#include<iostream>
using namespace std;

class Node
{
	public:
		int data;
		Node *next;
		
		Node(int value)
		{
			data = value;
			next = NULL;
		}
};

Node *CreateLinkedList(int arr[], int index, int size)
{
	// Base case
	if(index == size)
	{
		return NULL;
	}
	
	Node *temp;
	temp = new Node(arr[index]);
	temp->next = CreateLinkedList(arr, index+1, size);
	return temp; 
}

int main()
{   
	Node *Head;
	Head = NULL;
	
	int arr[] = {2,4,6,8,10};
	
	Head = CreateLinkedList(arr,0,5);
	
	//Delete a node at start.
	
	if(Head!=NULL)
	{
		Node *temp = Head;
		Head = Head->next;
		delete temp; 
	}
	
	// Print the value;
	                                    
	Node *temp = Head;
	while(temp!=NULL)
	{ 
		cout<<temp->data<<"->";
		temp=temp->next;
	}
	cout<<"NULL";
}


//========================================DELETE NODE FROM MIDDLE IN THE LINKEDLIST (MIDDLE,START,END)=================================
#include<iostream>
using namespace std;

class Node {
public:
    int data;
    Node *next;

    Node(int value) {
        data = value;
        next = NULL;
    }
};

Node* DeleteNode(Node* head, int x) {
    if (head == NULL) return NULL; // Check for empty list

    // If deleting the head node
    if (x == 1) {
        Node *temp = head;
        head = head->next;
        delete temp; // Correctly delete the node
        return head;
    }

    Node *curr = head;
    Node *prev = NULL;

    // Traverse to the node before the one to be deleted
    while (x-- >= 0 && curr != NULL) {
        prev = curr;
        curr = curr->next;
    }

    // If curr is NULL, x was out of bounds
    if (curr == NULL) return head;

    // Delete the node
    prev->next = curr->next;
    delete curr;

    return head;
}

void PrintList(Node* head) {
    Node *temp = head;
    while (temp != NULL) {
        cout << temp->data << "->";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}

int main() {
    Node *Head = NULL;

    // Creating linked list from an array
    int arr[] = {2, 4, 6, 8, 10};
    for (int i=0;i<5;i++) {
        Node* newNode = new Node(arr[i]);
        newNode->next = Head;
        Head = newNode;
    }

    cout << "Original List: ";
    PrintList(Head);

    // Deleting the last node (which is the 5th node, in this case)
    Head = DeleteNode(Head, 1);

    cout << "List after deleting last node: ";
    PrintList(Head);

    // Cleanup: Free remaining nodes (if necessary)
    while (Head != NULL) {
        Node *temp = Head;
        Head = Head->next;
        delete temp;
    }

    return 0;
}


//=======================================REVERSE OF LINKEDLIST USING ARRAY =====================================================
#include<iostream>
using namespace std;

class Node {
public:
    int data;
    Node *next;

    Node(int value) {
        data = value;
        next = NULL;
    }
};

// Function to reverse the linked list using an array
Node* ReverseLinkedList(Node* head) {
    if (head == NULL) return NULL;

    // Step 1: Calculate the length of the linked list
    int length = 0;
    Node* temp = head;
    while (temp != NULL) {
        length++;
        temp = temp->next;
    }

    // Step 2: Create an array to store the elements
    int* arr = new int[length];
    temp = head;
    for (int i = 0; i < length; i++) {
        arr[i] = temp->data;
        temp = temp->next;
    }

    // Step 3: Reverse the array
    for (int i = 0; i < length / 2; i++) {
        swap(arr[i], arr[length - i - 1]);
    }

    // Step 4: Rebuild the linked list from the reversed array
    Node* newHead = new Node(arr[0]);
    Node* current = newHead;
    for (int i = 1; i < length; i++) {
        current->next = new Node(arr[i]);
        current = current->next;
    }

    // Clean up the allocated array
    delete[] arr;

    return newHead;
}

// Function to print the linked list
void PrintList(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        cout << temp->data << " -> ";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}

// Main function
int main() {
	
	Node *Head = NULL;
     int arr[] = {2, 4, 6, 8, 10};
    for (int i=0;i<5;i++) {
        Node* newNode = new Node(arr[i]);
        newNode->next = Head;
        Head = newNode;
    }
    cout << "Original List: ";
    PrintList(Head);

    Head = ReverseLinkedList(Head);

    cout << "Reversed List: ";
    PrintList(Head);

    // Cleanup: Free remaining nodes
    while (Head != NULL) {
        Node* temp = Head;
        Head = Head->next;
        delete temp;
    }

    return 0;
}


//================================FIND THE MIDDLE OF THE LINKED LIST =========================================================
#include<iostream>
using namespace std;

class Node {
public:
    int data;
    Node *next;

    Node(int value) {
        data = value;
        next = NULL;
    }
};

// Function to find the middle of the linked list using an array
int FindMiddle(Node* head) {
    if (head == NULL) return -1; // Return -1 if the list is empty

    // Step 1: Calculate the length of the linked list
    int length = 0;
    Node* temp = head;
    while (temp != NULL) {
        length++;
        temp = temp->next;
    }

    // Step 2: Create an array to store the elements
    int* arr = new int[length];
    temp = head;
    for (int i = 0; i < length; i++) {
        arr[i] = temp->data;
        temp = temp->next;
    }

    // Step 3: Find the middle element
    int middleIndex = length / 2;
    int middleValue = arr[middleIndex];

    // Clean up the allocated array
    delete[] arr;

    return middleValue; // Return the middle value
}

// Function to print the linked list
void PrintList(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        cout << temp->data << " -> ";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}

// Main function
int main() {
    Node *Head = NULL;

    // Creating linked list from an array
    int arr[] = {2, 4, 6, 8, 10};
    for (int i=0;i<5;i++) {
        Node* newNode = new Node(arr[i]);
        newNode->next = Head;
        Head = newNode;
    }

    cout << "Original List: ";
    PrintList(Head);

    int middle = FindMiddle(Head);
    cout << "Middle Element: " << middle << endl;

    // Cleanup: Free remaining nodes
    while (Head != NULL) {
        Node* temp = Head;
        Head = Head->next;
        delete temp;
    }

    return 0;
}


//================================FIND THE MIDDLE OF THE LINKED LIST BY CONCEPT OF SLOW AND FAST POINTER=========================================================
#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;

    Node(int value) {
        data = value;
        next = NULL;
    }
};

// Function to find the middle of the linked list using slow and fast pointers
Node* FindMiddle(Node* head) {
    if (head == NULL) return NULL; // Return nullptr if the list is empty

    Node* slow = head;    // Slow pointer starts at the head
    Node* fast = head;    // Fast pointer also starts at the head

    // Move fast pointer two steps and slow pointer one step
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;          // Move slow pointer by one
        fast = fast->next->next;   // Move fast pointer by two
    }

    return slow; // Slow pointer will be at the middle when fast pointer reaches the end
}

// Function to print the linked list
void PrintList(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        cout << temp->data << " -> ";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}

// Main function
int main() {
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Original List: ";
    PrintList(head);

    Node* middleNode = FindMiddle(head);
    if (middleNode != NULL) {
        cout << "Middle Element: " << middleNode->data << endl;
    } else {
        cout << "The list is empty." << endl;
    }

    // Cleanup: Free remaining nodes
    while (head != NULL) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }

    return 0;
}

============DOUBLY LINKED LIST==============DOUBLY LINKED LIST=====================DOUBLY LINKED LIST========================DOUBLY LINKED LIST===========================
============DOUBLY LINKED LIST==============DOUBLY LINKED LIST=====================DOUBLY LINKED LIST========================DOUBLY LINKED LIST===========================
============DOUBLY LINKED LIST==============DOUBLY LINKED LIST=====================DOUBLY LINKED LIST========================DOUBLY LINKED LIST===========================
============DOUBLY LINKED LIST==============DOUBLY LINKED LIST=====================DOUBLY LINKED LIST========================DOUBLY LINKED LIST===========================

//========================================INSERTION AT THE BEGNING OF DOUBLY LINKED LIST ===========================================================
#include<iostream>
using namespace std;


class Node
{
	public: 
	int data;
	Node *next;
	Node* prev;
	
	Node(int value)
	{
		data = value;
		next = NULL;
		prev = NULL;
	}
};


int main()
{
	Node *Head , *temp;
	temp = Head = NULL;
	
	int arr[] = {2,4,6,8,10};
	
	for(int i=0;i<5;i++)
	{
		if(Head == NULL)
		{
			Head = new Node(arr[i]);
			temp = Head;
		}
		
		else
		{
			Node*temp = new Node(arr[i]);
			temp->next=Head;
			Head->prev = temp;
			Head = temp;
		}
	}
	
	
	while(Head!=NULL)
	{
		cout<<Head->data<<"->";
		Head = Head->next;
	}
	cout<<"NULL";
}


//********************************************************THIS IS THE BEST EXAMPLE OF INSERTION AT START***********************************************************************************
#include<iostream>
using namespace std;


class Node
{
	public: 
	int data;
	Node *next;
	Node* prev;
	
	Node(int value)
	{
		data = value;
		next = NULL;
		prev = NULL;
	}
};


int main()
{
	Node *Head , *tail,*temp;
	tail = Head = NULL;
	
	int arr[] = {2,4,6,8,10};
	
	for(int i=0;i<5;i++)
	{
		if(Head == NULL)
		{
			Head = new Node(arr[i]);
			tail = Head;
		}
		
		else
		{
			Node*temp = new Node(arr[i]);
			tail->next=temp;
			temp->prev = tail;
			tail = temp;
		}
	}
	
	if(Head == NULL)
		{
			Head = new Node(5);
			temp = Head;
		}
		
		else
		{
			Node*temp = new Node(5);
			temp->next=Head;
			Head->prev = temp;
			Head = temp;
		}
	
	Node * trav = Head;
	while(trav!=NULL)
	{
		cout<<trav->data<<"->";
		trav = trav->next;
	}
	cout<<"NULL";
}



//========================================INSERTION AT THE END OF DOUBLY LINKED LIST ===========================================================

#include<iostream>
using namespace std;


class Node
{
	public: 
	int data;
	Node *next;
	Node* prev;
	
	Node(int value)
	{
		data = value;
		next = NULL;
		prev = NULL;
	}
};


int main()
{
	Node *Head , *tail;
	tail = Head = NULL;
	
	int arr[] = {2,4,6,8,10};
	
	for(int i=0;i<5;i++)
	{
		if(Head == NULL)
		{
			Head = new Node(arr[i]);
			tail = Head;
		}
		
		else
		{
			Node*temp = new Node(arr[i]);
			tail->next=temp;
			temp->prev = tail;
			tail = temp;
		}
	}
	
	Node * trav = Head;
	while(trav!=NULL)
	{
		cout<<trav->data<<"->";
		trav = trav->next;
	}
	cout<<"NULL";
}



//*************************************************************INSERTION AT MIDDLE(ANY POSITION) IN DOUBLY LINKEDLIST ********************************************************************
#include<iostream>
using namespace std;


class Node
{
	public: 
	int data;
	Node *next;
	Node* prev;
	
	Node(int value)
	{
		data = value;
		next = NULL;
		prev = NULL;
	}
};


int main()
{
	Node *Head , *tail;
	tail = Head = NULL;
	
	int arr[] = {2,4,6,8,10};
	
	for(int i=0;i<5;i++)
	{
		if(Head == NULL)
		{
			Head = new Node(arr[i]);
			tail = Head;
		}
		
		else
		{
			Node*temp = new Node(arr[i]);
			tail->next=temp;
			temp->prev = tail;
			tail = temp;
		}
	}
	int pos= 5;
	//insert at start
	if(pos ==0)
	{
		//if linkedlist doesnt exist
		if(Head==NULL)
		{
			Head = new Node(5);
		}
		//if exist
		else
		{
			Node *temp =new Node(5);
			temp->next = Head;
			Head->prev = temp;
			Head = temp;
		}
	}
	else
	{
		Node*curr = Head;
    	while(--pos)
	    {
		    curr = curr->next;
	    };
	    //insert at end;
	    if(curr->next==NULL)
	    {
	    	Node *temp = new Node(5);
	    	temp->prev = curr;
	    	curr->next = temp;
		}
	    Node *temp = new Node(5);
	    temp->next=curr->next;
	    temp->prev=curr;
	    curr->next=temp;
	    temp->next->prev=temp;
	    Node * trav = Head;
	}
	Node *trav = Head;
	while(trav!=NULL)
	{
		cout<<trav->data<<"->";
		trav = trav->next;
	}
	cout<<"NULL";
}


//=================================  DELETE AT THE FRONT IN DOUBLY LINKEDLIST  ===============================================================
#include<iostream>
using namespace std;


class Node
{
	public: 
	int data;
	Node *next;
	Node* prev;
	
	Node(int value)
	{
		data = value;
		next = NULL;
		prev = NULL;
	}
};


int main()
{
	Node *Head , *tail;
	tail = Head = NULL;
	
	int arr[] = {2,4,6,8,10};
	
	for(int i=0;i<5;i++)
	{
		if(Head == NULL)
		{
			Head = new Node(arr[i]);
			tail = Head;
		}
		
		else
		{
			Node*temp = new Node(arr[i]);
			tail->next=temp;
			temp->prev = tail;
			tail = temp;
		}
	}
    if(Head!=NULL)
    {
    	Node *temp = Head;
    	Head = Head->next;
    	delete temp;
    	if(Head!=NULL)
    	{
    		Head->prev=NULL;
		}
	}
	Node *trav = Head;
	while(trav!=NULL)
	{
		cout<<trav->data<<"->";
		trav = trav->next;
	}
	cout<<"NULL";
}


// #######################################################################DELETE A NODE AT SPECIFIC POSITION IN DOUBLY LINKEDLIST ###################################################

// C++ Program to delete node at a specific position
// in Doubly Linked List

#include <iostream>
using namespace std;

class Node {
    public:
        int data;
        Node * prev;
        Node * next;
        Node(int d) {
            data = d;
            prev = next = NULL;
        }
};

// Function to delete a node at a specific position 
// in the doubly linked list
Node * delPos(Node* head, int pos) {

    // If the list is empty
    if (head == NULL)
        return head;

    Node * curr = head;

    // Traverse to the node at the given position
    for (int i = 1; curr != NULL && i < pos; ++i) {
        curr = curr -> next;
    }

    // If the position is out of range
    if (curr == NULL)
        return head;

    // Update the previous node's next pointer
    if (curr -> prev != NULL)
        curr -> prev -> next = curr -> next;

    // Update the next node's prev pointer
    if (curr -> next != NULL)
        curr -> next -> prev = curr -> prev;

    // If the node to be deleted is the head node
    if (head == curr)
        head = curr -> next;

    // Deallocate memory for the deleted node
    delete curr;
    return head;
}

void printList(Node * head) {
    Node * curr = head;
    while (curr != NULL) {
        cout << curr -> data << " ";
        curr = curr -> next;
    }
    cout << endl;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    Node * head = new Node(1);
    head -> next = new Node(2);
    head -> next -> prev = head;
    head -> next -> next = new Node(3);
    head -> next -> next -> prev = head -> next;

    head = delPos(head, 3);

    printList(head);

    return 0;
}


============STACK==============STACK=====================STACK========================STACK===========================
============STACK==============STACK=====================STACK========================STACK===========================
============STACK==============STACK=====================STACK========================STACK===========================
============STACK==============STACK=====================STACK========================STACK===========================


//=============================BASIC STACK OPERATIONS=============================
#include<iostream>
using namespace std;

// Implement it with array
class Stack
{
	int *arr;
	int size;
	int top;
	
	public:
		//constructor
		Stack(int s)
		{
			size = s;
			top = -1;
			arr = new int[s];
		}
		
		//Push
		void push(int value)
		{
			if(top == size -1)
			{
				cout<<"Stack Overflow\n";
				return;
			}
			else
			{
				top++;
				arr[top] = value;
				cout<<"Pushed "<<value<<" into the stack\n";
			}
		}
		//Pop
		void pop()
		{
			if(top == -1)
			{
				cout<<"Stack underflow\n";
			}
			else
			{
				cout<<"Popped "<<arr[top]<<" from the stack\n";
				top--;
			}
		}
		//Peek
		int peek()
		{
			if(top == -1)
			{
				cout<<"Stack is empty\n";
				return -1;
			}
			else
			{
				return arr[top];
			}
		}
		//IsEmpty
		bool IsEmpty()
		{
			return top == -1;
		}
		//IsSize
		int IsSize()
		{
			return top+1;
		}
};

int main()
{
	Stack S(5);
	S.push(5);
	S.push(6);
	S.push(8);
	S.push(9);
	S.push(4);
	S.push(3);
	S.pop();
	S.pop();
	S.pop();
	S.pop();
	S.pop();
	S.pop();
	cout<<S.peek()<<endl;
	cout<<S.IsEmpty()<<endl;
	cout<<S.IsSize()<<endl;


}


//=============================SOLVE EMPTY(-1) OR IF WE PASS -1 TO PUSH THEN HOW CAN WE DIFFERENTIATE  =============================
#include<iostream>
using namespace std;

// Implement it with array
class Stack
{
	int *arr;
	int size;
	int top;
	
	public:
		bool flag;
		//constructor
		Stack(int s)
		{
			size = s;
			top = -1;
			arr = new int[s];
			flag = 1;// is stack is empty then it return 1.
		}
		
		//Push
		void push(int value)
		{
			if(top == size -1)
			{
				cout<<"Stack Overflow\n";
				return;
			}
			else
			{
				top++;
				arr[top] = value;
				cout<<"Pushed "<<value<<" into the stack\n";
				flag = 0;
			}
		}
		//Pop
		void pop()
		{
			if(top == -1)
			{
				cout<<"Stack underflow\n";
			}
			else
			{
				cout<<"Popped "<<arr[top]<<" from the stack\n";
				top--;
				if(top == -1)
				flag = 1;
			}
		}
		//Peek
		int peek()
		{
			if(top == -1)
			{
				cout<<"Stack is empty\n";
				return -1;
			}
			else
			{
				return arr[top];
			}
		}
		//IsEmpty
		bool IsEmpty()
		{
			return top == -1;
		}
		//IsSize
		int IsSize()
		{
			return top+1;
		}
};

int main()
{
	Stack S(5);
	S.push();
	int value = S.peek();
	if(S.flag == 0)
	cout<<value<<endl;
}


//=============================STACK USING LINKEDLIST==========================
#include<iostream>
using namespace std;

class Node
{
	public:
		int data;
		Node *next;
		
		Node(int value)
		{
			data = value;
			next = NULL;
		}
};

class Stack
{
	Node *top;
	int size; // actual size of stack.
	
	public:
		Stack()
		{
			top = NULL;
			size = 0;
		}
		
		//push
		void push(int value)
		{
			Node *temp = new Node(value);
			if(temp == NULL)
			{
				cout<<"Stack is Overflow\n";
				return ;
			}
			else
			{
				temp->next = top;
				top = temp;
				size++;
				cout<<"Pushed "<<value<<" into the stack\n";
			}
		}
		//pop
		void pop()
		{
			if(top==NULL)
			{
				cout<<"Stack underflow\n";
				return;
			}
			else
			{
				Node *temp = top;
				cout<<"Popped "<<top->data<<" from the stack\n";
				top = top->next;
				delete temp;
				size--;
			}
		}
		//peek
		int peek()
		{
			if(top == NULL)
			{
				cout<<"Stack is empty\n";
				return -1;
			}
			else
			{
				return top->data;
			}
		}
		//IsEmpty
		bool IsEmpty()
		{
			return top == NULL;
		}
		//IsSize
		int IsSize()
		{
			return size;
		}
};

int main()
{
	Stack S;
	S.push(64);
	S.push(63);
	S.push(62);
	S.push(61);
	S.pop();
	cout<<S.peek()<<endl;
	cout<<S.IsSize()<<endl;
	cout<<S.IsEmpty()<<endl;
}


//=============================stack with STL inbuilt liberary=======================
#include<iostream>
#include<stack>
using namespace std;

int main()
{
	stack<int>azeem;
	azeem.push(1);
	azeem.push(2);
	azeem.push(3);
	azeem.push(4);
	azeem.push(5);
	
	cout<<azeem.size()<<endl;
	cout<<azeem.top()<<endl;
	cout<<azeem.empty()<<endl;
}


#include<iostream>
//==========================STACK USING ARRAY =========================================
#include<stack>
using namespace std;
class Stack
{
	int capacity;
	int *arr;
	int top;
	public:
		Stack(int c)
		{
			this->capacity = c;
			arr = new int [c];
			this->top = -1;
		}
		
		void push(int data)
		{
			if(this->top == this->capacity-1)
			{
				cout<<"Overflow\n";
				return;
			}
			this->top++;
			this->arr[this->top] = data;
		}
		
		int pop()
		{
			if(this->top == -1)
			{
				cout<<"Underflow\n";
				return INT_MIN;
			}
			this->top--;
		}
		
		int getTop()
		{
			if(this->top == -1)
			{
				cout<<"Underflow\n";
				return INT_MIN;
			}
			return this->arr[this->top];
		}
		
		bool isEmpty()
		{
			return this->top == -1;
		}
		
		int size ()
		{
			return this->top +1;
		}
		
		bool isFull()
		{
			return this->top == this->capacity -1;
		}
};

int main()
{
	Stack st(5);
	st.push(1);
	st.push(2);
	st.push(3);
	cout<<st.getTop()<<"\n";
	st.push(4);
	st.push(5);
	cout<<st.getTop()<<"\n";
	st.push(5);
    return 0;

}


============Queue==============Queue=====================Queue========================Queue===========================
============Queue==============Queue=====================Queue========================Queue===========================
============Queue==============Queue=====================Queue========================Queue===========================
============Queue==============Queue=====================Queue========================Queue===========================

//==============================Singular Queue==============================================
#include<iostream>
using namespace std;

class Queue
{
	int *arr;
	int front, rear, size;
	
	public:
		//Constructor
		Queue(int n)
		{
			arr =new int[n];
			size = n;
			front = rear = -1;
		}
	
	//If queue is empty or not
	
	bool IsEmpty()
	{
		return front ==-1;
	}
	
	//Queue if full or not
	
	bool IsFull()
	{
		return rear == size-1;
	}
	
	//push element into queue
	
	void push(int x)
	{
		//Empty
		if(IsEmpty())
		{
			cout<<"Pushed "<<x<<" into the Queue\n";
			front = rear = 0;
			arr[0] = x;
			return;
		}
		
		//full
		else if(IsFull())
		{
			cout<<"Queue Overflow\n";
			return;
		}
		
		// insert
		
		else
		{
			rear = rear +1;
			arr[rear] = x;
			cout<<"Pushed "<<x<<" into the Queue\n";
		}
	}
 	
 	void pop()
 	{
 		//empty
 		if(IsEmpty())
 		{
 			cout<<"Queue underflow\n";
 			return;
		}
		
		else
		{
			if(front == rear)
			{
				cout<<"Poped "<<arr[front]<<" from the Queue\n";
				front = rear = -1;
			}
			else
			{
				cout<<"Poped "<<arr[front]<<" from the Queue\n";	
				front = front+1;
			}
		}
	}
	
	//starting mai konsa element rkkha hai
	int Start()
	{
		if(IsEmpty())
		{
			cout<<"Queue is empty \n";
			return -1;
		}
		else
		{
			return arr[front]; 
		}
	}
 	
};

int main()
{
	Queue q(5);
	q.push(5);
	q.push(15);
	q.push(25);
	q.pop();
	q.pop();
	q.pop();
	int x=q.Start();
	if(!q.IsEmpty())
	cout<<x<<" ";
}


//==============================Circular Queue==============================================
#include<iostream>
using namespace std;

class Queue
{
	int *arr;
	int front, rear, size;
	
	public:
		//Constructor
		Queue(int n)
		{
			arr =new int[n];
			size = n;
			front = rear = -1;
		}
	
	//If queue is empty or not
	
	bool IsEmpty()
	{
		return front ==-1;
	}
	
	//Queue if full or not
	
	bool IsFull()
	{
		return (rear+1)%size == front;
	}
	
	//push element into queue
	
	void push(int x)
	{
		//Empty
		if(IsEmpty())
		{
			cout<<"Pushed "<<x<<" into the Queue\n";
			front = rear = 0;
			arr[0] = x;
			return;
		}
		
		//full
		else if(IsFull())
		{
			cout<<"Queue Overflow\n";
			return;
		}
		
		// insert
		
		else
		{
			rear = (rear+1)%size;
			arr[rear] = x;
			cout<<"Pushed "<<x<<" into the Queue\n";
		}
	}
 	
 	void pop()
 	{
 		//empty
 		if(IsEmpty())
 		{
 			cout<<"Queue underflow\n";
 			return;
		}
		
		else
		{
			if(front == rear)
			{
				cout<<"Poped "<<arr[front]<<" from the Queue\n";
				front = rear = -1;
			}
			else
			{
				cout<<"Poped "<<arr[front]<<" from the Queue\n";	
				front = (front+1)%size;
			}
		}
	}
	
	//starting mai konsa element rkkha hai
	int Start()
	{
		if(IsEmpty())
		{
			cout<<"Queue is empty \n";
			return -1;
		}
		else
		{
			return arr[front]; 
		}
	}
 	
};

int main()
{
	Queue q(5);
	q.push(5);
	q.push(15);
	q.push(25);
	q.push(35);
	q.pop();
	q.push(45);
	q.push(55);
}



//============================== Queue USING LINKEDLIST==============================================
#include<iostream>
using namespace std;

class Node
{
	public:
		int data;
		Node *next;
		
	Node(int value)
	{
		data = value;
		next = NULL;
	}
};

class Queue
{
	Node *front;
	Node *rear;
	
	public:
		
		Queue()
		{
			front = rear = NULL;
		}
		
		bool IsEmpty()
		{
			return front == NULL;
		}
		
		void push(int x)
		{
			if(IsEmpty())
			{
				cout<<"Pushed "<<x<<" into the queue\n";
				front = rear = new Node(x);
				return;
			}
			else
			{
				rear->next = new Node(x);
				cout<<"Pushed "<<x<<" into the queue\n";
				rear = rear->next;  
			}
		}
		
		int start()
		{
			if(IsEmpty())
			{
				cout<<"Queue is empty\n";
				return -1;
			}
			else
			{
				return front->data;
			}
		}
		
		void pop()
		{
			if(IsEmpty())
			{
				cout<<"Queue Underflow\n";
				return;
			}
			else
			{
				cout<<"Popped "<<front->data<<" from the queue\n";
				Node*temp = front;
				front = front->next;
				delete temp;
			}
		}
		
};

int main()
{
	Queue q;
	q.push(5);
	q.push(15);
	q.push(25);
	q.push(35);
	q.pop();
	cout<<q.start()<<endl;
}


//============================== Queue USING STL==============================================
#include<iostream>
#include<queue>
using namespace std;

int main()
{
	queue<int>q;
	q.push(10);
	q.push(20);
	q.push(30);
	q.push(40);
	
	q.pop();
	cout<<q.front()<<endl;
	cout<<q.back()<<endl;
	cout<<q.size()<<endl;
	cout<<q.empty()<<endl;
}


//=============================DEQUEUE USING LINKEDLIST==========================
#include<iostream>
using namespace std;

class Node
{
	public:
		int data;
		Node *next, *prev;
		
	Node(int value)
	{
		data = value;
		next = prev = NULL;
	} 
};

class Dequeue
{
	Node *front , *rear;
	public:
		Dequeue()
		{
			front = rear = NULL;
		}
		
	//push front
	void push_front(int x)
	{
		//Empty
		if(front == NULL)
		{
			front = rear = new Node(x);
			cout<<"Pushed "<<x<<" in front of Dequeue\n";
			return;
		}
		else
		{
			Node *temp = new Node(x);
			temp->next = front;
			front->prev = front;
			front = temp;
			cout<<"Pushed "<<x<<" in front of Dequeue\n";
			return;
		}
	}
	
	
	//push back
	void push_back(int x)
	{
		//Empty
		if(front == NULL)
		{
			front = rear = new Node(x);
			cout<<"Pushed "<<x<<" in back of Dequeue\n";
			return;
		}
		else
		{
			Node *temp = new Node(x);
			rear->next = temp;
			temp->prev = rear;
			rear = temp;
			cout<<"Pushed "<<x<<" in back of Dequeue\n";
			return;
		}
	}
	
	
	//pop front
	void pop_front()
	{
		//Empty
		if(front == NULL)
		{
			cout<<"Dequeue Underflow\n";
			return;
		}
		else
		{
			Node *temp= front;
			cout<<"Popped "<<temp->data<<" from front\n";
			front = front->next;
			delete temp;
			//Greater than 1 node
			if(front!=NULL)
			{
				front->prev = NULL;
			}
			// 1 node
			else
			{
				rear = NULL; 
			}
		}
	}
	//pop back
	void pop_back()
	{
		//Empty
		if(front == NULL)
		{
			cout<<"Dequeue Underflow\n";
			return;
		}
		else
		{
			Node *temp= rear;
			cout<<"Popped "<<temp->data<<" from back\n";
			rear = rear->prev;
			delete temp;
			//Greater than 1 node
			if(rear!=NULL)
			{
				rear->next = NULL;
			}
			// 1 node
			else
			{
				front = NULL; 
			}
		}
	}
	// start
	int start()
	{
		if(front == NULL)
		{
			return -1;
		}
		else
		{
			return front->data;
		}
	}
	
	//end
	int end()
	{
		if(front == NULL)
		{
			return -1;
		}
		else
		{
			return rear->data;
		}
	}
};

int main()
{
	Dequeue q;
	q.push_back(5);
	q.push_front(10);
	q.pop_back();
	cout<<q.start()<<endl;
	cout<<q.end()<<endl;
	q.pop_back();

}
